# 掌握 Rust 中的所有权

**Understanding Ownership**

所有权（Ownership） 作为 Rust 最为独特的特性，而对这门语言其余部分有着深刻影响。正是所有权，使得 Rust 在无需垃圾收集器的情况下，保证了内存安全，因此掌握所有权的工作原理，就尤为重要。在这一章，将就所有权，以及几个与所有权有关的特性：借用、切片，以及 Rust 在内存中放置数据的方式等，进行讲解。

## 何谓所有权

*所有权* 是一套对 Rust 程序管理内存方式进行监管的规则（*ownership* is a set of rules that governs how a Rust program manages memory）。所有程序都必须对其在运行期间运用计算机内存的方式，进行管理。一些语言有着伴随其程序运行，而持续查找不再用到内存的垃圾回收；在别的一些语言中，程序员必须显式地分配和释放内存。Rust 采用了第三条路线：内存经由一种，有着一套编译器会进行检查的规则的，所有权系统，而得到管理。在这些规则的任何一条被违反了时，程序就不会编译。所有权的任何一个特性，都不会在程序运行期间，拖慢程序运行速度。

由于对许多程序员来说，所有权都是个新概念，因此要些时间来习惯他。好消息则是随着对 Rust 与所有权系统的那些规则的愈加熟练，那么就会发现自然地开发出安全且高效的代码，变得越来越容易了。请务必坚持下去！

在掌握了所有权后，就会对那些令到 Rust 成为一门独特编程语言的特性，有扎实掌握。在本章中，将通过完成一些，着重于甚为常见的数据结构：字符串示例，而掌握到所有权。

> **内存栈与堆（the Stack and the Heap）**
>
> 众多编程语言，都不会要求进程考虑内存栈与堆。不过在像是 Rust 这样的系统编程语言中，某个值是在栈上还是在堆上，就会对语言的行为表现造成影响，还会影响到不得不做出明确决定的原因。本章稍后将讲到的所有权的一些部分，是与内存栈和堆有关的，因此这里是关于他们的一点简要说明，作为预备知识。
>
> 内存栈和堆，都属于在运行时代码可用内存的组成部分，只不过他们是以不同方式架构组织起来的。栈（the stack）以其收到值的顺序，保存着一些值，并以相反的顺序，将这些值移除。这被成为 *后进先出（last in, first out）*。设想有一叠盘子：在添加更多盘子时，是要把新的盘子放在盘子堆顶上，而在要用个盘子时，就要从顶上拿。从底下或中间添加或拿走盘子，都是不行的！添加数据被称为 “压入栈（pushing onto the stack）”，而移除数据被称为 *压出栈（popping off the stack）*。保存在栈上的数据，必须要有已知的、固定的大小。相反，那些运行时未知大小，或大小可能会变化的数据，就必须保存在堆上。
>
> 内存堆的组织程度较低：在要将数据放在堆上时，就要请求确切数量的空间。内存分配器会在堆上找到一处足够大的空白位点，将其标记为正在使用中，然后返回一个 *指针（pointer）*，即那个点位的地址。此过程被称为 *堆上分配（allocating on the heap）*，而有时会去掉堆，而简称为 *分配（allocating）* （相比于堆上分配，将值压入到栈上，则不被认为是内存分配）。由于到堆的指针是已知的、固定大小的，因此就可以将该指针存储在栈上，而在想要具体数据时，就必须依循该指针。请设想正坐在某个餐馆里。在进到餐馆时，就要报出跟你们组的人数，进而餐馆员工就会找出一张可以坐下所有人的空桌子，并把你们带过去。在你们组有人迟到时，他们就可以询问是坐在哪张桌子，而找到你们。
> 
> 由于内存分配器永远不必搜寻一个位置，来存储新数据，因此压入栈比起在堆上分配空间要快；存储新数据的地方，始终时在栈顶部。而与此相比，在内存堆上分配空间，由于内存分配器必须首先找到一个足够大的空间，来保存新数据，并随后还要为准备好下一次内存分配，而完成对此次分配的登记，因此这样就需要更多的工作了。
>
> 由于必须要循着某个指针去获取到数据，因此访问内存堆上的数据，与访问栈上的数据相比，也要慢一些。现代处理器在较少地在内存中跳跃时，会更快。延续上面的比喻，设想餐馆里的一名服务员，正在接收来自许多台餐桌的点餐。那么一次获取到一个桌子的全部点餐，再去往下一桌，无疑是最高效的。而从餐桌 A 拿到一份点餐，再从餐桌 B 拿到一份点餐，随后又从餐桌 A 拿到一份，然后又从餐桌 B 再拿到一份，这样无疑就是慢得多的过程了。在同一令牌下，如果处理器处理的数据与另一数据靠近（就像在栈上那样），而不是远离另一数据（就像在内存堆上可能的情形），那么处理器无疑会更好地完成他的工作。在内存堆上分配大量空间，也是需要时间的。
>
> 在代码对某个函数进行调用时，传入到该函数的值（潜在包含了指向内存堆上数据的指针），以及该函数的本地变量，都是被压入到栈上的。在该函数结束运行后，这些值就被从栈上弹出。
>
> 对代码的哪些部分正在使用内存堆上的哪些数据进行追踪，最小化内存堆上的重复数据数量，并对内存堆上的未使用数据进行清理而不至于耗尽内存空间，等等，都是所有权要解决的问题。一旦掌握了所有权，就再也不需要经常考虑栈和堆了，而明白所有权主要目的为对内存堆进行管理，则会有助于解释所有权为何会以他的方式运作。


### 所有权规则

首先，来看看这些所有权规则。在完成后面用于演示这些规则的示例时，请牢记这些规则：

- Rust 中的每个值，都有一个名为 *所有者（owner）* 的变量；
- 同一时间，只能有一个所有者；
- 在其所有者超出作用域时（scope），该值就被丢弃。


### 变量作用域（variable scope）

既然已经学了 Rust 基础语法，接下来就不会在示例中，包含整个的 `fn main() {` 代码了，那么若跟随这些示例，就要确保把接下来的这些示例，自己手动放在 `main` 函数里头。这样的结果就是，这些示例会比较精炼一点，而着重于具体细节而不是那些样板代码。

作为所有权的首个示例，这里将考察一下一些变量的 *作用域（scope）*。作用域是指某个项目在程序中的有效范围。以下面这个变量来说：

```rust
let s = "hello";
```

这里的变量 `s` 指向一个字符串字面值，其中的字符串的值，则是被硬编码到这个程序的文本。自变量被声明处，到当前 *作用域* 结束处，变量都是有效的。下面清单 4-1 给出了一个带有对变量 `s` 在何处有效，进行注解注释的程序：

```rust
{                       // 变量 s 在这里是无效的，他还没被声明出来
    let s = "hello";    // s 自此往下都是有效的

    // 对变量 s 执行一些操作
}                       // 此时该作用域就结束了，而变量 s 也不再有效
```

*清单 4-1：变量与其间有效的作用域（a variable and the scope in which it is valid）*

换句话说，这里有两个重点：

- 当变量 `s` 一旦来到作用域，他就有效了（when `s` comes *into scope*, it is valid）；
- 他会保持有效，直到 *超出作用域*（it remains valid until it goes *out of scope*）。


此刻，作用域与变量何时有效，二者之间的关系其他语言中的此类关系类似。现在就要通过引入 `String` 类型，在此理解之上进行建构了。

### `String` 类型

为了对所有权的那些规则进行演示，就需要比前面第 3 章的 ["数据类型"](Ch03_Common_Programming_Concepts.md#data-types) 小节中，讲到那些类型复杂一些的数据类型。前面讲到的那些类型，都是已知大小的、可存储在栈上，且在他们的作用域结束时会被弹出去，在代码其他部分需要在不同作用域中用到同样值时，这些类型还可被快速而简单地复制，而构造出新的、独立实例来。不过这里要审视的是存储在内存堆上的数据，进而对 Rust 是如何知晓何时要清理这些内存堆上的数据进行探索，那么 `String` 类型就是极佳的示例了。

这里将着重于 `String` 类型与所有权有关的部分。这些方面同样适用于其他的、不论是由标准库还是自己创建的综合数据类型（complex data types）。在 [第 8 章](Ch08_Common_Collections.md#strings) 将深入讲解 `String` 类型。

前面已经见到过字符串字面值，那里有个硬编码到程序里的字符串值。字符串字面值很方便，但对于那些打算使用文本的每种情形，他们并不适合。一个原因是字符串字面值为不可变的。另一个原因则是，在编写代码时，并非每个字符串的值都是已知的：比如，假设要获取用户输入并存储下来，该怎么做呢？对于这样的情形，Rust 有着第二种字符串类型，即 `String`。这种类型对分配到内存堆上的数据加以管理，并因此而具备了存储在编译时未知数量文本的能力。使用 `String` 类型的 `from` 函数，就可以从字符串字面值，创建出一个 `String` 类型的值来，如下所示：

```rust
let s = String::from("hello"); 
// 变量 s 的类型为：String, 而此前字面值中的变量 s 的类型为：&str
```

其中的双冒号（`::`）运算符，实现了将这个特定 `from` 函数，处于 `String` 类型的命名空间之下，而无需使用类似于 `string_from` 这种名字了。在第 5 章的 [方法语法](Ch05_Using_Structs_to_Structure_Related_Data.md#method-syntax) 小节，并在第 7 章的 [对模组树中的某个项目进行引用的路径](Ch07_Managing_Growing_Projects_with_Packages_Crates_and_Modules.md#paths-for-referring-to-an-item-in-the-module-tree) 小节，对模块的命名空间的介绍中， 将对这种语法进行更多讲解。

这种字符串，*能* 被改变：

```rust
let mut s = String::from("hello");
s.push_str(", world!"); // push_str() 方法把字面值追加到某个字符串
println! ("{}", s); // 这将打印出 `hello, world!`
```

那么，到底字面值与 `String` 类型有何不同？为何 `String` 可以被改变，而字面值却不能？区别就在于，这两种类型处理内存的方式，是不同的。


### 内存与内存分配

在字符串字面值的示例中，在编译时就知道其内容，因此那文本就被直接硬编码到了最终的可执行文件。这就是为何字符串字面值快速高效的原因。然而这些属性，只是来源于字符串字面值的不可变性而已。不幸的是，对于这些在编译时大小未知的，且在运行期间大小可能改变的各个文本，是无法为他们而将一块置为二进制形式的。

对于 `String` 类型，为了支持可变、可增长的一段文本，就需要在内存堆上分配某个数量的内存，而这个数量在编译时则是未知的，用来保存文本的那些内容。这就意味着：

- 该内存必须在运行时向内存分配器请求；
- 在使用完那个 `String` 值之后，就需要某种将这片内存交回给内存分配器的方式。

其中第一部分是由代码编写者完成的：在调用 `String::from` 时，这个 `from` 方法的实现，就请求了他所需的内存了。在各种编程语言中，这是相当通行的做法。

然而，这第二部分就有所不同了。在带有 *垃圾收集器（garbage collector, GC）* 的那些语言中，对那些不再是正被使用中的内存的追踪和清理，就是由垃圾收集器完成的，对此这里无需去考虑。而在大多数不带垃圾收集器的语言，就要靠代码编写者自己，去识别内存在何时不再被使用，并像请求内存时一样，要调用代码显式地退回不再不再使用的内存。要正确完成这样的内存退回，早已成为一个历史悠久的编程难题。一旦忘记显式地退回不再使用的内存，那么就会造成内存浪费。而过早地退回，又将造成变量失效。重复退回了不再使用的内存，也会造成程序错误。就需要严格地一个 `allocate` 对应一个 `free`。

Rust 采用了不同的路线：一旦某个变量超出了作用域，那么该变量所拥有的内存空间，就被自动退回。
