# 掌握 Rust 中的所有权

**Understanding Ownership**

所有权（Ownership） 作为 Rust 最为独特的特性，而对这门语言其余部分有着深刻影响。正是所有权，使得 Rust 在无需垃圾收集器的情况下，保证了内存安全，因此掌握所有权的工作原理，就尤为重要。在这一章，将就所有权，以及几个与所有权有关的特性：借用、切片，以及 Rust 在内存中放置数据的方式等，进行讲解。

## 何谓所有权

*所有权* 是一套对 Rust 程序管理内存方式进行监管的规则（*ownership* is a set of rules that governs how a Rust program manages memory）。所有程序都必须对其在运行期间运用计算机内存的方式，进行管理。一些语言有着伴随其程序运行，而持续查找不再用到内存的垃圾回收；在别的一些语言中，程序员必须显式地分配和释放内存。Rust 采用了第三条路线：内存经由一种，有着一套编译器会进行检查的规则的，所有权系统，而得到管理。在这些规则的任何一条被违反了时，程序就不会编译。所有权的任何一个特性，都不会在程序运行期间，拖慢程序运行速度。

由于对许多程序员来说，所有权都是个新概念，因此要些时间来习惯他。好消息则是随着对 Rust 与所有权系统的那些规则的愈加熟练，那么就会发现自然地开发出安全且高效的代码，变得越来越容易了。请务必坚持下去！

在掌握了所有权后，就会对那些令到 Rust 成为一门独特编程语言的特性，有扎实掌握。在本章中，将通过完成一些，着重于甚为常见的数据结构：字符串示例，而掌握到所有权。

> **内存栈与堆（the Stack and the Heap）**
>
> 众多编程语言，都不会要求进程考虑内存栈与堆。不过在像是 Rust 这样的系统编程语言中，某个值是在栈上还是在堆上，就会对语言的行为表现造成影响，还会影响到不得不做出明确决定的原因。本章稍后将讲到的所有权的一些部分，是与内存栈和堆有关的，因此这里是关于他们的一点简要说明，作为预备知识。
>
> 内存栈和堆，都属于在运行时代码可用内存的组成部分，只不过他们是以不同方式架构组织起来的。栈（the stack）以其收到值的顺序，保存着一些值，并以相反的顺序，将这些值移除。这被成为 *后进先出（last in, first out）*。设想有一叠盘子：在添加更多盘子时，是要把新的盘子放在盘子堆顶上，而在要用个盘子时，就要从顶上拿。从底下或中间添加或拿走盘子，都是不行的！添加数据被称为 “压入栈（pushing onto the stack）”，而移除数据被称为 *压出栈（popping off the stack）*。保存在栈上的数据，必须要有已知的、固定的大小。相反，那些运行时未知大小，或大小可能会变化的数据，就必须保存在堆上。
>
> 内存堆的组织程度较低：在要将数据放在堆上时，就要请求确切数量的空间。内存分配器会在堆上找到一处足够大的空白位点，将其标记为正在使用中，然后返回一个 *指针（pointer）*，即那个点位的地址。此过程被称为 *堆上分配（allocating on the heap）*，而有时会去掉堆，而简称为 *分配（allocating）* （相比于堆上分配，将值压入到栈上，则不被认为是内存分配）。
