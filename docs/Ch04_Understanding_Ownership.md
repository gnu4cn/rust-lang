# 掌握 Rust 中的所有权

**Understanding Ownership**

所有权（Ownership） 作为 Rust 最为独特的特性，而对这门语言其余部分有着深刻影响。正是所有权，使得 Rust 在无需垃圾收集器的情况下，保证了内存安全，因此掌握所有权的工作原理，就尤为重要。在这一章，将就所有权，以及几个与所有权有关的特性：借用、切片，以及 Rust 在内存中放置数据的方式等，进行讲解。

## 何谓所有权

*所有权* 是一套对 Rust 程序管理内存方式进行监管的规则（*ownership* is a set of rules that governs how a Rust program manages memory）。所有程序都必须对其在运行期间运用计算机内存的方式，进行管理。一些语言有着伴随其程序运行，而持续查找不再用到内存的垃圾回收；在别的一些语言中，程序员必须显式地分配和释放内存。Rust 采用了第三条路线：内存经由一种，有着一套编译器会进行检查的规则的，所有权系统，而得到管理。在这些规则的任何一条被违反了时，程序就不会编译。所有权的任何一个特性，都不会在程序运行期间，拖慢程序运行速度。

由于对许多程序员来说，所有权都是个新概念，因此要些时间来习惯他。好消息则是随着对 Rust 与所有权系统的那些规则的愈加熟练，那么就会发现自然地开发出安全且高效的代码，变得越来越容易了。请务必坚持下去！

在掌握了所有权后，就会对那些令到 Rust 成为一门独特编程语言的特性，有扎实掌握。在本章中，将通过完成一些，着重于甚为常见的数据结构：字符串示例，而掌握到所有权。

> **内存栈与堆（the Stack and the Heap）**
>
> 众多编程语言，都不会要求进程考虑内存栈与堆。不过在像是 Rust 这样的系统编程语言中，某个值是在栈上还是在堆上，就会对语言的行为表现造成影响，还会影响到不得不做出明确决定的原因。本章稍后将讲到的所有权的一些部分，是与内存栈和堆有关的，因此这里是关于他们的一点简要说明，作为预备知识。
>
> 内存栈和堆，都属于在运行时代码可用内存的组成部分，只不过他们是以不同方式架构组织起来的。栈（the stack）以其收到值的顺序，保存着一些值，并以相反的顺序，将这些值移除。这被成为 *后进先出（last in, first out）*。设想有一叠盘子：在添加更多盘子时，是要把新的盘子放在盘子堆顶上，而在要用个盘子时，就要从顶上拿。从底下或中间添加或拿走盘子，都是不行的！添加数据被称为 “压入栈（pushing onto the stack）”，而移除数据被称为 *压出栈（popping off the stack）*。保存在栈上的数据，必须要有已知的、固定的大小。相反，那些运行时未知大小，或大小可能会变化的数据，就必须保存在堆上。
>
> 内存堆的组织程度较低：在要将数据放在堆上时，就要请求确切数量的空间。内存分配器会在堆上找到一处足够大的空白位点，将其标记为正在使用中，然后返回一个 *指针（pointer）*，即那个点位的地址。此过程被称为 *堆上分配（allocating on the heap）*，而有时会去掉堆，而简称为 *分配（allocating）* （相比于堆上分配，将值压入到栈上，则不被认为是内存分配）。由于到堆的指针是已知的、固定大小的，因此就可以将该指针存储在栈上，而在想要具体数据时，就必须依循该指针。请设想正坐在某个餐馆里。在进到餐馆时，就要报出跟你们组的人数，进而餐馆员工就会找出一张可以坐下所有人的空桌子，并把你们带过去。在你们组有人迟到时，他们就可以询问是坐在哪张桌子，而找到你们。
> 
> 由于内存分配器永远不必搜寻一个位置，来存储新数据，因此压入栈比起在堆上分配空间要快；存储新数据的地方，始终时在栈顶部。而与此相比，在内存堆上分配空间，由于内存分配器必须首先找到一个足够大的空间，来保存新数据，并随后还要为准备好下一次内存分配，而完成对此次分配的登记，因此这样就需要更多的工作了。
>
> 由于必须要循着某个指针去获取到数据，因此访问内存堆上的数据，与访问栈上的数据相比，也要慢一些。现代处理器在较少地在内存中跳跃时，会更快。延续上面的比喻，设想餐馆里的一名服务员，正在接收来自许多台餐桌的点餐。那么一次获取到一个桌子的全部点餐，再去往下一桌，无疑是最高效的。而从餐桌 A 拿到一份点餐，再从餐桌 B 拿到一份点餐，随后又从餐桌 A 拿到一份，然后又从餐桌 B 再拿到一份，这样无疑就是慢得多的过程了。在同一令牌下，如果处理器处理的数据与另一数据靠近（就像在栈上那样），而不是远离另一数据（就像在内存堆上可能的情形），那么处理器无疑会更好地完成他的工作。在内存堆上分配大量空间，也是需要时间的。
>
> 在代码对某个函数进行调用时，传入到该函数的值（潜在包含了指向内存堆上数据的指针），以及该函数的本地变量，都是被压入到栈上的。在该函数结束运行后，这些值就被从栈上弹出。
>
> 对代码的哪些部分正在使用内存堆上的哪些数据进行追踪，最小化内存堆上的重复数据数量，并对内存堆上的未使用数据进行清理而不至于耗尽内存空间，等等，都是所有权要解决的问题。一旦掌握了所有权，就再也不需要经常考虑栈和堆了，而明白所有权主要目的为对内存堆进行管理，则会有助于解释所有权为何会以他的方式运作。


### 所有权规则

首先，来看看这些所有权规则。在完成后面用于演示这些规则的示例时，请牢记这些规则：

- Rust 中的每个值，都有一个名为 *所有者（owner）* 的变量；
- 同一时间，只能有一个所有者；
- 在其所有者超出作用域时（scope），该值就被丢弃。


### 变量作用域（variable scope）

既然已经学了 Rust 基础语法，接下来就不会在示例中，包含整个的 `fn main() {` 代码了，那么若跟随这些示例，就要确保把接下来的这些示例，自己手动放在 `main` 函数里头。这样的结果就是，这些示例会比较精炼一点，而着重于具体细节而不是那些样板代码。

作为所有权的首个示例，这里将考察一下一些变量的 *作用域（scope）*。作用域是指某个项目在程序中的有效范围。以下面这个变量来说：

```rust
let s = "hello";
```

这里的变量 `s` 指向一个字符串字面值，其中的字符串的值，则是被硬编码到这个程序的文本。自变量被声明处，到当前 *作用域* 结束处，变量都是有效的。下面清单 4-1 给出了一个带有对变量 `s` 在何处有效，进行注解注释的程序：

```rust
{                       // 变量 s 在这里是无效的，他还没被声明出来
    let s = "hello";    // s 自此往下都是有效的

    // 对变量 s 执行一些操作
}                       // 此时该作用域就结束了，而变量 s 也不再有效
```

*清单 4-1：变量与其间有效的作用域（a variable and the scope in which it is valid）*

换句话说，这里有两个重点：

- 当变量 `s` 一旦来到作用域，他就有效了（when `s` comes *into scope*, it is valid）；
- 他会保持有效，直到 *超出作用域*（it remains valid until it goes *out of scope*）。


此刻，作用域与变量何时有效，二者之间的关系其他语言中的此类关系类似。现在就要通过引入 `String` 类型，在此理解之上进行建构了。

### `String` 类型

为了对所有权的那些规则进行演示，就需要比前面第 3 章的 ["数据类型"](Ch03_Common_Programming_Concepts.md#data-types) 小节中，讲到那些类型复杂一些的数据类型。前面讲到的那些类型，都是已知大小的、可存储在栈上，且在他们的作用域结束时会被弹出去，在代码其他部分需要在不同作用域中用到同样值时，这些类型还可被快速而简单地复制，而构造出新的、独立实例来。不过这里要审视的是存储在内存堆上的数据，进而对 Rust 是如何知晓何时要清理这些内存堆上的数据进行探索，那么 `String` 类型就是极佳的示例了。

这里将着重于 `String` 类型与所有权有关的部分。这些方面同样适用于其他的、不论是由标准库还是自己创建的综合数据类型（complex data types）。在 [第 8 章](Ch08_Common_Collections.md#strings) 将深入讲解 `String` 类型。

前面已经见到过字符串字面值，那里有个硬编码到程序里的字符串值。字符串字面值很方便，但对于那些打算使用文本的每种情形，他们并不适合。一个原因是字符串字面值为不可变的。另一个原因则是，在编写代码时，并非每个字符串的值都是已知的：比如，假设要获取用户输入并存储下来，该怎么做呢？对于这样的情形，Rust 有着第二种字符串类型，即 `String`。这种类型对分配到内存堆上的数据加以管理，并因此而具备了存储在编译时未知数量文本的能力。使用 `String` 类型的 `from` 函数，就可以从字符串字面值，创建出一个 `String` 类型的值来，如下所示：

```rust
let s = String::from("hello"); 
// 变量 s 的类型为：String, 而此前字面值中的变量 s 的类型为：&str
```

其中的双冒号（`::`）运算符，实现了将这个特定 `from` 函数，处于 `String` 类型的命名空间之下，而无需使用类似于 `string_from` 这种名字了。在第 5 章的 [方法语法](Ch05_Using_Structs_to_Structure_Related_Data.md#method-syntax) 小节，并在第 7 章的 [对模组树中的某个项目进行引用的路径](Ch07_Managing_Growing_Projects_with_Packages_Crates_and_Modules.md#paths-for-referring-to-an-item-in-the-module-tree) 小节，对模块的命名空间的介绍中， 将对这种语法进行更多讲解。

这种字符串，*能* 被改变：

```rust
let mut s = String::from("hello");
s.push_str(", world!"); // push_str() 方法把字面值追加到某个字符串
println! ("{}", s); // 这将打印出 `hello, world!`
```

那么，到底字面值与 `String` 类型有何不同？为何 `String` 可以被改变，而字面值却不能？区别就在于，这两种类型处理内存的方式，是不同的。


### 内存与内存分配

在字符串字面值的示例中，在编译时就知道其内容，因此那文本就被直接硬编码到了最终的可执行文件。这就是为何字符串字面值快速高效的原因。然而这些属性，只是来源于字符串字面值的不可变性而已。不幸的是，对于这些在编译时大小未知的，且在运行期间大小可能改变的各个文本，是无法为他们而将一块置为二进制形式的。

对于 `String` 类型，为了支持可变、可增长的一段文本，就需要在内存堆上分配某个数量的内存，而这个数量在编译时则是未知的，用来保存文本的那些内容。这就意味着：

- 该内存必须在运行时向内存分配器请求；
- 在使用完那个 `String` 值之后，就需要某种将这片内存交回给内存分配器的方式。

其中第一部分是由代码编写者完成的：在调用 `String::from` 时，这个 `from` 方法的实现，就请求了他所需的内存了。在各种编程语言中，这是相当通行的做法。

然而，这第二部分就有所不同了。在带有 *垃圾收集器（garbage collector, GC）* 的那些语言中，对那些不再是正被使用中的内存的追踪和清理，就是由垃圾收集器完成的，对此这里无需去考虑。而在大多数不带垃圾收集器的语言，就要靠代码编写者自己，去识别内存在何时不再被使用，并像请求内存时一样，要调用代码显式地退回不再不再使用的内存。要正确完成这样的内存退回，早已成为一个历史悠久的编程难题。一旦忘记显式地退回不再使用的内存，那么就会造成内存浪费。而过早地退回，又将造成变量失效。重复退回了不再使用的内存，也会造成程序错误。就需要严格地一个 `allocate` 对应一个 `free`。

Rust 采用了不同的路线：一旦某个变量超出了作用域，那么该变量所持有的内存空间，就被自动退回。下面是对清单 4-1 那个作用域示例，使用 `String` 而非字符串字面值的一个版本：

```rust
    {
        let s = String::from("hello");  // 变量 s 自此往下是有效的

        // 以变量 s 完成一些操作
    }                                   // 该作用域到此时结束，而变量 s
                                        // 不再有效
```

其中就存在一个，可将那个 `String` 类型的值所需的内存，退回给内存分配器的天然时间点：即在变量 `s` 超出作用域时。在变量超于作用域时，Rust 就会主动调用一个特殊函数。该函数名为 `drop`，且该函数就是 `String` 类型编写者，可将用于退回内存代码放在这个函数里。在那个结束花括号处，Rust 会自动调用这个 `drop` 函数。

> 注意：在 C++ 中，这种在某项目生命周期结束时，资源重分配的模式，有时被称为 *资源请求即初始化*（in C++, this pattern of deallocating resources at the end of an item's lifetime is sometimes called *Resource Acquisition Is Initialization, RAII*）。若曾用过 RAII 模式，那么 Rust 中的这个 `drop` 函数就会不那么陌生了。

这种模式对 Rust 代码编写方式有深远影响。这种模式在此刻可能看起来简单，但在想要多个变量都使用早先布置在内存堆上的数据时，这样较为复杂的情况下，代码行为表现就会无法预期。现在就来对这些情况中的一些，探索一下。

### 变量与数据户操作方式之一：迁移

在 Rust 中，多个变量与同一数据之间的互操作，会有多种方式。下面来看看一个在清单 4-2 使用到整数的示例：

```rust
let x = 5;
let y = x;
```

*清单 4-2：将变量 `x` 的整数值，赋值给变量 `y`*

这里或许能猜到这段代码正在完成的事情：“把值 `5` 绑定到变量 `x`；然后构造一份 `x` 中值的拷贝并将其绑定到变量 `y`。” 现在就有了两个变量，`x` 与 `y`，且他们都等于 `5`。由于整数是有着已知的、固定大小的简单值，因此这实际上就是正在发生的事情，且这两个 `5` 的值都是被压入到栈上的。

那么现在来看看 `String` 的版本：

```rust
let s1 = String::from("hello");
let s2 = s1;
```

这代码看起来与上面的非常相似，那么这里就可以假定其工作方式也是一样的：那就是，第二行将构造出一个 `s1` 中值的拷贝，并将该拷贝绑定到 `s2`。不过这并非真的是实际发生的样子。

请参阅下面的图 4-1，来看看幕后的 `String` 到底发生了什么。`String` 类型的值，是由三部分构成，在下图中的左边有给出：一个指向到保存该字符串内容内存的指针、一个长度，和一个该字符串的容量。这样一组数据被保存在栈上。下图的右边，即是内存堆上保存字符串内容的内存。

![Rust 中 `String` 类型的本质](images/Ch04_01.svg)

*图 4-1：绑定到变量 `s1` 的、保存着值 `hello` 的一个 `String` 类型值在内存中的表示*

其中的长度，即为以字节计数、该`String` 值内容正使用着的内存数量。而容量则是该 `String` 值从内存分配器处收到的、以字节计算的内存数量。长度与容量之间的区别，会相当重要，但在现在这个示例的情形下尚不重要，到目前未知，是可以忽略容量这个部分的。

在将 `s1` 赋值给 `s2` 时，这个 `String` 值被拷贝了，这里的拷贝，是说拷贝栈上的指针、长度和容量。这里并未拷贝指针指向的、内存堆上的数据。也就是说，内存中数据的表示，如下图 4-2 所示：

![有着变量 `s1` 的指针、长度与容量拷贝的变量 `s2` 在内存中的表示](images/Ch04_02.svg)

*图 4-2：有着变量 `s1` 的指针、长度与容量拷贝的变量 `s2` 在内存中的表示*

这种表示与下图 4-3 并不相同，那才是 Rust 对内存堆上的数据进行拷贝时，内存看起来的样子。但如果 Rust 像这样做，那么当内存堆上的数据较大时， `s2 = s1` 的这个操作将会在运行时性能开销上代价高昂。

![`s2 = s1` 操作的另一种可能：Rust 拷贝内存堆数据](images/Ch04_03.png)

*图 4-3：`s2 = s1` 操作的另一种可能：Rust 拷贝内存堆数据*

早先曾讲过，在变量超出作用域后，Rust 会自动调用那个 `drop` 函数，而清理掉那个变量的堆内存。但图 4-2 则给出了两个指针都指向同一位置的情况。这就是个问题了：在 `s2` 与 `s1` 都超出作用域时，他们都将尝试去释放那同样的内存。这被称为 *双重释放（double free）* 错误，是先前提到过的内存安全错误之一。二次释放内存，可导致内存内存损坏，而内存损坏则会潜在导致安全漏洞。

为确保内存安全，Rust 在代码行 `s2 = s1` 之后，便不再认为 `s1` 是有效的了。因此，在 `s1` 超出作用域后，Rust 便不需要释放任何内存。下面就来检查一下，在 `s2` 创建出来后，去尝试使用 `s1` 会发生什么；这样做是不会工作的：

```rust
    let s1 = String::from("hello");  // 这里 s 的类型为：String
    let s2 = s1;

    println! ("{}", s1);
```

由于 Rust 阻止了对失效引用变量的使用，因此将收到一个下面这样的错误：

```console
$ cargo run                                                                           
   Compiling string_demo v0.1.0 (/home/peng/rust-lang/projects/string_demo)
warning: unused variable: `s2`
 --> src/main.rs:3:9
  |
3 |     let s2 = s1;
  |         ^^ help: if this is intentional, prefix it with an underscore: `_s2`
  |
  = note: `#[warn(unused_variables)]` on by default

error[E0382]: borrow of moved value: `s1`
 --> src/main.rs:5:21
  |
2 |     let s1 = String::from("hello");  // 这里 s 的类型为：String
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 | 
5 |     println! ("{}", s1);
  |                     ^^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0382`.
warning: `string_demo` (bin "string_demo") generated 1 warning
error: could not compile `string_demo` due to previous error; 1 warning emitted
```

若在使用其他编程语言时，曾听说过 *浅拷贝（shallow copy）* 和 *深拷贝（deep copy）* 这两个说法，那么这种对指针、长度与容量的拷贝，而未拷贝数据的概念，或许听起来像是进行了一次浅拷贝。但由于 Rust 还将第一个变量进行了失效处理，因此这里就不叫浅拷贝，而叫做 *迁移（move）*。在这个示例中，就会讲，变量 `s1` 已被 *迁移* 到变量 `s2` 里了。因此真实发生的事情，就是下图 4-4 显示的那样：

![在变量 `s1` 失效后内存中的表示](images/Ch04_04.svg)

*图 4-4：在变量 `s1` 失效后内存中的表示*

这就解决了问题！在只有 `s2` 有效之下，在变量 `s2` 超出作用域后，那么就只有他会释放内存了，于是就解决了双重内存释放问题。

此外，这样做还实现了一种设计上的选择：Rust 绝不会自动创建数据的 “深” 拷贝。由此，任何 *自动* 拷贝，都可认为在运行时性能开销上的影响很小。

### 变量与数据交互方式之二：克隆

在 *确实* 打算对 `String` 的内存堆数据，而非只是栈数据进行深度拷贝时，就可以使用一个常用的、名为 `clone` 的方法。在第 5 章将讨论到方法语法，而由于在众多编程语言中，方法都是共同特性，那么此前大概率是见到方法的。

下面是一个发挥作用的 `clone` 方法示例：

```rust
fn main() {
    let s1 = String::from("hello");  // 这里 s 的类型为：String
    let s2 = s1.clone();

    println! ("s1 = {}, s2 = {}", s1, s2);
}
```

这段代码工作起来毫无问题，并显式地产生出图 4-3 中给出的行为，其间内存堆数据确实得以拷贝。

当看到一个对 `clone` 方法的调用时，那么就明白正有一些随意的代码在被执行，且那代码可能开销高昂。对此方法的调用，是某些不同一般的事情在发生的明显标志。

### 唯栈数据：拷贝（stack-only data: copy）

尚有另一个至今还未讲到的小问题。正使用着整数的这段代码 -- 其中一部分在下面的清单 4-2 中给出了 -- 会工作并是有效代码：

```rust
let x = 5;
let y = x;

println! ("x = {}, y = {}", x, y);
```

然而这段代码，似乎与前面刚刚了解到的相抵触：这里没有对 `clone` 的调用，但变量 `x` 依然有效，而并未迁移到变量 `y` 中去。

原因就在于，诸如整数这样的，在编译时大小已知的类型，都是被整个存储在栈上，那么构造他们具体值的拷贝是迅速的。那就意味着，在构造出变量 `y` 之后，就没有理由要去阻止变量 `x` 一直有效了。换句话说，此时的深拷贝与浅拷贝之间，是没有区别的，因此对 `clone` 进行调用，不会完成与通常的浅拷贝有任何区别的事情，进而就能忽略这个 `clone` 方法。

Rust 有个叫做 `Copy` 特质（在第 10 章将对特质，traits，进行更多的讲解）的，可放在那些存储于栈上、像是整数这样类型之上的特殊注解。在某个类型实现了 `Copy` 特质时，此类型的变量，就会在赋值给另一变量之后，仍然有效。在某个类型，或这个类型的任何部分曾实现了 `Drop` 特质，那么 Rust 就不会允许再用 `Copy` 特质，对此类型加以注解了。若某个类型需要在其值超出作用域后，还要进行某些特殊处理，且又将 `Copy` 注解添加到那个类型，那么就会收到编译时错误（if the type needs something special to happen when the value goes out of scope and we add the `Copy` annotation to that type, we'll get a compile-time error）。要了解如何将 `Copy` 注解，添加到自己编写的类型而实现这个 `Copy` 特质，请参阅附录 C 中 [可派生特质（derivable traits）](Ch21_Appendix.md#derivable-traits)。

那么到底哪些类型要实现 `Copy` 特质呢？可查阅给定类型的文档，来确定相应类型是否有实现 `Copy` 特质，不过作为一般规则，任何组别的简单标量值，都可对 `Copy` 特质加以实现，以及不要求分配内存或其他形式资源的类型，也都可以实现 `Copy` 特质（any group of simple scalar values can implement `Copy`, and nothing that requires allocation or is some form of resource can implement `Copy`）。下面就是一些实现 `Copy` 特质的类型：

- 全部的整型，比如 `u32`；
- 布尔值类型，`bool`，即值 `true` 与 `false`；
- 全部浮点数类型，比如 `f64`;
- 字符类型，`char`;
- 仅包含了实现 `Copy` 特质的那些类型的元组类型。比如 `(i32, i32)` 这个元组类型，就实现了 `Copy` 特质，而 `(i32, String)` 则没有。


### 所有权与函数

将值传递给函数的语法，与将值赋值给变量的语法，是类似的。将变量传递给函数，就会进行迁移或拷贝，这与赋值所做的别无二致。下面的清单 4-3 有着一个带有一些注解的示例，对其中的变量进入和超出作用域，进行了展示。

文件名：`src/main.rs`


```rust
fn main() {
    let s = String::from("hello");  // 变量 s 进到作用域
    
    takes_ownership(s);             // 变量 s 的值移入到这个函数......
                                    // ......进而变量 s 因此不再有效

    let x = 5;                      // 变量 x 进到作用域

    makes_copy(x);                  // 变量 x 移入到这个函数，
                                    // 但由于 i32 实现 `Copy` 特质，因此
                                    // 后面在使用变量 x 也是没问题的
}   // 到这里，变量 x 超出了作用域，接着便是变量 s。但由于变量 s 的值已被迁移，因此
    // 这里不会有特别的事情发生。

fn takes_ownership(some_string: String) {   // 变量 some_string 进到作用域
    println! ("{}", some_string);
}   // 到这里，变量 some_string 便超出作用域，同时 `drop` 方法被调用。支持
    // 变量 some_string 的内存被释放。

fn makes_copy(some_integer: i32) {  // 变量 some_integer 进到作用域
    println! ("{}", some_integer);
}   // 到这里，变量 some_integer 超出作用域。没有特别事情发生。
```

*清单 4-3：带所有权与作用域注解的函数*

> 注：下面的代码，仍然会报出：`use of moved value: ``some_string```错误：

```rust
fn takes_ownership(some_string: String) {
    println! ("{}", some_string);
    another_takes_ownership(some_string);
    third_takes_ownership(some_string);
}
```

在对 `takes_ownership` 的调用之后，尝试使用变量 `s` 时，Rust 就会抛出一个编译时错误。这样的静态检查，保护免于出错。请将使用变量 `s` 与变量 `x` 的代码添加到 `main` 函数中，来观察一下在哪些地方可以使用他们，以及所有权规则会怎样防止这样做。

### 返回值与作用域（return value and scope）

返回值也会转移所有权。下面的清单 4-4 给出了一个返回了某个值的函数的示例，该示例有着与清单 4-3 中的那些类似的注解。

文件名：`src/main.rs`

```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership 将其返回值
                                        // 迁移到变量 s1 中

    let s2 = String::from("hello");     // 变量 s2 进入作用域

    let s3 = takes_and_gives_bake(s2);  // 变量 s2 被迁移到 takes_and_gives_back
                                        // 中，该函数又将他的返回值迁移到变量 s3 中

    println! ("{}, {}", s1, s3);
}   // 到这里，变量 s3 超出作用域并不丢弃。变量 s2 已被迁移，因此什么也不会发生。而
    // 变量 s1 则超出作用域而被丢弃。

fn gives_ownership() -> String {    // 函数 gives_ownership 将把他的返回值，迁移
                                    // 到调用他的函数中（？不是调用他的变量吗）
    String::from("归你了")          // 此表达式的值将被返回，并迁出到调用函数
}

// 此函数接收一个 String 并要返回一个 String
fn takes_and_gives_bake(a_string: String) -> String {   // a_string 进入作用域
    a_string    // a_string 被返回，并迁出到调用函数
}
```

*清单 4-4：返回值的所有权转移*

变量的所有权每次都会依循同一模式：在将值赋值给另一变量时，所有权就得以迁移。在包含内存堆上数据的变量超出作用域时，除非数据所有权已被迁移到另一变量，否则超出作用域变量的值就会被 `drop` 给清理掉。

而在这个模式生效时，每个函数下的取得所有权与随后的交回所有权，就有点乏味了。在要某个函数使用某个值而不占据其所有权时，会怎样呢？如果希望再度使用传入到函数中的全部东西，而还要把这些传入的东西，和那些可能还要返回的函数体运算结果一起再传回来，那样就很烦人了。

如下面的清单 4-5 所示，Rust 确实允许使用一个元组，返回多个值：

文件名：`src/main.rs`

```rust
fn main() {
    let s1 = String::from("hello");

    let (s2, len): (String, usize) = calculate_length(s1);

    println! ("字符串 {} 的长度为：{}", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len();

    (s, length)
}
```

*清单 4-5：参数的所有权返回*

这虽然间接实现了函数使用变量而去占据变量所有权，但对于所有权这个应成为喜闻乐见的概念来说，这样做就过于形式化，且带来了大量工作负担。幸运的是，Rust 有着一项使用某个值而不转移所有权的特性，叫做 *引用（references）*。


## 引用与借用（references and borrowing）

清单 4-5 中那个元组的问题，就是因为那个 `String` 值已被迁移到 `calculate_length` 函数中，因此那里必须将那个 `String` 值返回给调用函数（the calling funciton, 即清单 4-5 中的 `main` 函数），进而在对 `calculate_length` 的调用之后，仍然可以使用那个 `String` 的堆上数据。然而，这里可提供到那个 `String` 值的引用。所谓 *引用*，与指针相像，在引用中的是个地址，循着该地址，就可以访问到保存在那个地址处的、为其他变量所拥有的数据了。与指针不同的是，在指向到某个特定类型的有效值上，引用是有保证的。下面就是应如何定义和使用，有着到某个对象的应用作为参数，而非占用值的所有权的方式下的 `calculate_length` 函数：

文件名：`src/main.rs`

```rust
fn main() {
    let s1 = String::from("hello");

    let length = calculate_length(&s1);

    println! ("字符串 {} 的长度为：{}", s1, length);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```

首先，注意到变量声明与函数返回值中的全部元组代码都不见了。其次，留意到这里是将 `&s1` 传入到 `calculate_length` 中的，同时在该函数的定义中，采用的是 `&String` 而非 `String`。这些 `&` 符号表示的是 *引用（references）*，而正是这些引用实现了无需占用某个值的所有权的情况下，对该值的引用。下图 4-5 对此概念进行了描述。

![指向 `String s1` 的 `&String s` 图示](images/Ch04_05.svg)

*图 4-5：指向 `String s1` 的 `&String s` 图示*


> 注意：通过使用 `&` 的引用的反面，即为 *解引用（dereferencing）*，解引用是以解引用运算符，`*`，完成的。在第 8 章中就会看到这个解引用运算符的使用，而在第 15 章中，则会对解引用的细节加以讨论。

来细看一下这里的函数调用：

```rust
let s1 = String::from("hello");
let len = calculate_length(&s1);
```

`&s1` 这样的语法，实现了创建一个指向到 `s1` 的值而不占有那个值的引用变量。由于引用不占用那个值，因此在引用变量停止使用时，引用变量指向的值就不会被丢弃。

与此类似，那个函数的签名同样使用 `&` 运算符来表明参数 `s` 的类型是个引用变量。下面就来添加一些说明性的注解：

```rust
fn calculate_length(s: &String) -> usize {  // 变量 s 为到某个 String 值的引用
    s.len()
}   // 到这里，变量 s 超出作用域。但由于他并没有他指向值的所有权，因此什么
    // 也不会发生。
```

变量 `s` 有效的作用域，与所有函数参数的作用域是相同的，而由于变量 `s` 不拥有经引用而指向的那个值的所有权，因此在变量 `s` 停止被使用时，那个所指向的值就不会被丢弃。在函数以引用变量，而非真实值作为参数时，由于整个就没有过所有权，那么就不再需要为了交回所有权而将那些值返回了。

那么在尝试修改某个正借用的物件时，又会发生什么呢？请尝试下面清单 4-6 中的代码。提前剧透一下：那代码就不会工作！

文件名：`src/main.rs`

```rust
fn main() {
    let s = String::from("hello");

    change(&s);
}

fn change(some_string: &String) {
    some_string.push_str(", world!");
}
```

*清单 4-6：尝试修改借用值*

下面就是编译器报错：

```console
$ cargo run
   Compiling ownership_demo v0.1.0 (/home/peng/rust-lang/projects/ownership_demo)
error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&` reference
 --> src/main.rs:8:5
  |
7 | fn change(some_string: &String) {
  |                        ------- help: consider changing this to be a mutable reference: `&mut String`
8 |     some_string.push_str(", world!");
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `some_string` is a `&` reference, so the data it refers to cannot be borrowed as mutable

For more information about this error, try `rustc --explain E0596`.
error: could not compile `ownership_demo` due to previous error
```

就跟那些默认为不可变的变量一样，引用变量也是这样的。是不允许去修改所引用的某个物件的。


### 可变的引用变量

以少量小的、使用 *可变引用变量（mutable reference）* 来取代使用引用变量，的调整，就可将清单 4-6 的代码修改为允许对借用值加以修改了：

文件名：`src/main.rs`

```rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);

    println! ("s：{}", s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world!");
}
```
