# 掌握 Rust 中的所有权

**Understanding Ownership**

所有权（Ownership） 作为 Rust 最为独特的特性，而对这门语言其余部分有着深刻影响。正是所有权，使得 Rust 在无需垃圾收集器的情况下，保证了内存安全，因此掌握所有权的工作原理，就尤为重要。在这一章，将就所有权，以及几个与所有权有关的特性：借用、切片，以及 Rust 在内存中放置数据的方式等，进行讲解。

## 何谓所有权

*所有权* 是一套对 Rust 程序管理内存方式进行监管的规则（*ownership* is a set of rules that governs how a Rust program manages memory）。所有程序都必须对其在运行期间运用计算机内存的方式，进行管理。一些语言有着伴随其程序运行，而持续查找不再用到内存的垃圾回收；在别的一些语言中，程序员必须显式地分配和释放内存。Rust 采用了第三条路线：内存经由一种，有着一套编译器会进行检查的规则的，所有权系统，而得到管理。在这些规则的任何一条被违反了时，程序就不会编译。所有权的任何一个特性，都不会在程序运行期间，拖慢程序运行速度。

由于对许多程序员来说，所有权都是个新概念，因此要些时间来习惯他。好消息则是随着对 Rust 与所有权系统的那些规则的愈加熟练，那么就会发现自然地开发出安全且高效的代码，变得越来越容易了。请务必坚持下去！

在掌握了所有权后，就会对那些令到 Rust 成为一门独特编程语言的特性，有扎实掌握。在本章中，将通过完成一些，着重于甚为常见的数据结构：字符串示例，而掌握到所有权。

> **内存栈与堆（the Stack and the Heap）**
>
> 众多编程语言，都不会要求进程考虑内存栈与堆。不过在像是 Rust 这样的系统编程语言中，某个值是在栈上还是在堆上，就会对语言的行为表现造成影响，还会影响到不得不做出明确决定的原因。本章稍后将讲到的所有权的一些部分，是与内存栈和堆有关的，因此这里是关于他们的一点简要说明，作为预备知识。
>
> 内存栈和堆，都属于在运行时代码可用内存的组成部分，只不过他们是以不同方式架构组织起来的。栈（the stack）以其收到值的顺序，保存着一些值，并以相反的顺序，将这些值移除。这被成为 *后进先出（last in, first out）*。设想有一叠盘子：在添加更多盘子时，是要把新的盘子放在盘子堆顶上，而在要用个盘子时，就要从顶上拿。从底下或中间添加或拿走盘子，都是不行的！添加数据被称为 “压入栈（pushing onto the stack）”，而移除数据被称为 *压出栈（popping off the stack）*。保存在栈上的数据，必须要有已知的、固定的大小。相反，那些运行时未知大小，或大小可能会变化的数据，就必须保存在堆上。
>
> 内存堆的组织程度较低：在要将数据放在堆上时，就要请求确切数量的空间。内存分配器会在堆上找到一处足够大的空白位点，将其标记为正在使用中，然后返回一个 *指针（pointer）*，即那个点位的地址。此过程被称为 *堆上分配（allocating on the heap）*，而有时会去掉堆，而简称为 *分配（allocating）* （相比于堆上分配，将值压入到栈上，则不被认为是内存分配）。由于到堆的指针是已知的、固定大小的，因此就可以将该指针存储在栈上，而在想要具体数据时，就必须依循该指针。请设想正坐在某个餐馆里。在进到餐馆时，就要报出跟你们组的人数，进而餐馆员工就会找出一张可以坐下所有人的空桌子，并把你们带过去。在你们组有人迟到时，他们就可以询问是坐在哪张桌子，而找到你们。
> 
> 由于内存分配器永远不必搜寻一个位置，来存储新数据，因此压入栈比起在堆上分配空间要快；存储新数据的地方，始终时在栈顶部。而与此相比，在内存堆上分配空间，由于内存分配器必须首先找到一个足够大的空间，来保存新数据，并随后还要为准备好下一次内存分配，而完成对此次分配的登记，因此这样就需要更多的工作了。
>
> 由于必须要循着某个指针去获取到数据，因此访问内存堆上的数据，与访问栈上的数据相比，也要慢一些。现代处理器在较少地在内存中跳跃时，会更快。延续上面的比喻，设想餐馆里的一名服务员，正在接收来自许多台餐桌的点餐。那么一次获取到一个桌子的全部点餐，再去往下一桌，无疑是最高效的。而从餐桌 A 拿到一份点餐，再从餐桌 B 拿到一份点餐，随后又从餐桌 A 拿到一份，然后又从餐桌 B 再拿到一份，这样无疑就是慢得多的过程了。在同一令牌下，如果处理器处理的数据与另一数据靠近（就像在栈上那样），而不是远离另一数据（就像在内存堆上可能的情形），那么处理器无疑会更好地完成他的工作。在内存堆上分配大量空间，也是需要时间的。
>
> 在代码对某个函数进行调用时，传入到该函数的值（潜在包含了指向内存堆上数据的指针），以及该函数的本地变量，都是被压入到栈上的。在该函数结束运行后，这些值就被从栈上弹出。
>
> 对代码的哪些部分正在使用内存堆上的哪些数据进行追踪，最小化内存堆上的重复数据数量，并对内存堆上的未使用数据进行清理而不至于耗尽内存空间，等等，都是所有权要解决的问题。一旦掌握了所有权，就再也不需要经常考虑栈和堆了，而明白所有权主要目的为对内存堆进行管理，则会有助于解释所有权为何会以他的方式运作。


## 所有权规则

首先，来看看这些所有权规则。在完成后面用于演示这些规则的示例时，请牢记这些规则：

- Rust 中的每个值，都有一个名为其 *所有者（owner）* 的变量；
- 同一时间，只能有一个所有者；
- 在其所有者超出作用域时（scope），该值就被丢弃。

## 变量作用域（variable scope）


