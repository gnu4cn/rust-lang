# 一些常用的集合

**Common Collections**

Rust 标准库中包含了几种名为 *集合（collections）* 的有用数据结构。大多数其他数据类型，都表示某个特定值，而集合则可包含多个值。与内建的数组和元组类型不同，这些集合所指向的数据，是存储在堆上的，这就意味着在编译时不需要知道数据的数量，进而在程序运行时，这些数据数量可增加或减少。每种集合都有不同能力与开销，针对应用程序当下情况，而选择恰当的一种集合，则是随着时间推移，要发展的一项编程技能。本章中，将讨论在 Rust 程序中，经常被用到的三种集合：

- *矢量* 允许存储并列的数个值；
- *字符串* 是一些字符的集合。早先曾提到过 `String` 类型，而本章就要深入讨论到他；
- *哈希映射（hash map）* 允许将某个值与特定键进行关联。他是一种更为通用数据结构、名为 *映射（map）* 的一个特定实现。

要了解由标准库所提供的其他类别集合，请参阅 [文档](https://doc.rust-lang.org/std/collections/index.html)。

这里将讨论怎样创建与更新矢量、字符串与哈希映射，同时会讨论他们因何而变得特殊。


## 使用矢量类型，对值清单进行存储

**Storing Lists of Values with Vectors**

这里要看的第一个集合，便是 `Vec<T>`，也叫做 *矢量（vector）* 类型。矢量类型允许将多个值，存储在单个的、将全部这些值挨个放入内存的数据结构中。矢量类型仅能存储同一类型的这些值。在有着某个数据项目清单，比如某个文件中的那些文本行，或购物车中那些货品价格时，那么矢量类型就是有用的。


### 创建一个新的矢量值

要创建出一个新的空矢量值，就要调用 `Vec::new()` 函数，如下清单 8-1 所示：

```rust
    let v: Vec<i32> = Vec::new();
```

*清单 8-1：创建一个新的、用于保持一些类型 `i32` 值的空矢量*

请注意这里添加了个类型注解。由于这里没有往这个矢量插入任何值，因此 Rust 是不清楚这里要存储何种类别元素的。这是个重点。矢量值是使用泛型实现的；在后面第 10 章中，就会讲到怎样在自己的类型中使用泛型。而此刻，就要明白由标准库提供的这个 `Vec<T>` 可以保存任何类型。在创建保存特定类型的矢量时，可在尖括号里头指定那个类型。在清单 8-1 中，就告诉了 Rust，`v` 中的那个 `Vec<T>` 将保存 `i32` 类型的元素。

而更为常见的则是，会创建带有初始值的 `Vec<T>`，同时 Rust 就会推断出要存储的值类型，那么就很少会进行这样的类型注解。Rust 贴心地提供了 `vec!` 这个宏，这个宏就会创建出一个新的、保存给到他的那些值的矢量来。下面清单 8-2 就创建了一个新的、保存了值 `1`、`2` 与 `3` 的 `Vec<i32>`。之所以那个整数类型为 `i32`，是由于 `i32` 正是默认的整数类型，如同第 3 章的 ["数据类型"](Ch03_Common_Programming_Concepts.md#data-types) 中所讨论的那样。

```rust
let v = vec! [1, 2, 3];
```

*清单 8-2：创建一个新的包含了值的矢量*

由于这里已经给定了一些初始化 `i32` 的值，因此 Rust 就可以推断出 `v` 的类型为 `Vec<i32>`，而那个类型注解就不是必要的了。接下来，就要看看怎样修改矢量。


### 更新矢量

要创建出一个矢量，并随后将一些元素添加给他，就可以使用 `push` 方法，如下清单 8-3 中所示。

```rust
    let mut v = Vec::new();

    v.push(5);
    v.push(6);
    v.push(7);
    v.push(8);
```

*清单 8-3：使用 `push` 方法来把一些值添加到某个矢量*

正如第 3 章中所讨论的，这里与任何变量一样，在想要能修改矢量的值时，就要使用 `mut` 关键字，将其构造为可变。这里在矢量内部的数字，全部都是 `i32` 类型，而 Rust 就会从这些数据，推断出这个类型，因此这里不需要 `Vec<i32>` 类型注解。

### 丢弃某个矢量，就会丢弃他的元素

**Dropping a Vector Drops Its Elements**

与其他任何 `struct` 一样，矢量在超出作用域时，就会被释放掉，如下清单 8-4 所示。

```rust
    {
        let v = vec! [1, 2, 3, 4];

        // 对 v 执行一些操作
    } // 这里 v 就超出了作用域，而被释放掉
```

*清单 8-4：对矢量及其元素在何处被丢弃进行展示*

在这个矢量被丢弃时，那么他所有内容也会被丢弃，即他保存的那些整数将被清理掉。这初一看似乎直接明了，然而在开始触及到一些到该矢量元素的引用时，事情就会变得复杂。接下来就要解决这个问题！

### 读取矢量的元素

引用存储在矢量中某个值的方式有两种：经由索引，或使用 `get` 方法。在接下来的示例中，为讲得更清楚的原因，已经对从这些方法返回的值进行了注释。

下面清单 8-5 给出了访问矢量某个值的两种方式，即索引语法与 `get` 方法。

```rust
    let v = vec! [1, 2, 3, 4];

    let third: &i32 = &v[2];
    println! ("第三个元素为 {}", third);

    match v.get(2) {
        Some(third) => println! ("第三个元素为 {}", third),
        None => println! ("没有第三个元素。"),
    }
```

*清单 8-5：使用索引语法或 `get` 方法访问矢量中的某个元素*

请留意这里的两个细节。首先，由于矢量是以从零开始的数字进行索引，因此这里使用了索引值 `2` 来获取那第三个元素。其次，这里是通过同时使用 `&` 与 `[]`，获取第三个元素的，这就给到一个引用变量，而使用带有作为参数传递索引的 `get` 方法，给到的却是个 `Option<&T>` 值。

Rust 提供这两种引用某个元素方式的原因在于，有了这两种方式，就可以在尝试使用某个超出了既有元素范围的索引值时，对程序此时的表现加以选择。比如，下面就来看看在有着一个五个元素的矢量，而随后尝试以两种技巧，来访问位于索引 `100` 处元素时，会发生什么事情，如下清单 8-6 中所示。

```rust
